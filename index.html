<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Logic Tetris MVP – Levels 1 & 2</title>
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #a0cfff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #gameCanvas {
    border: 1px solid #333;
    background: transparent;
  }
  #slotContainer {
  position: absolute;
  left: 0;
  bottom: 0;
  width: 800px;
  display: none;   /* <-- JS will set this to "flex" at start */
}
  .slot {
  flex: 1;
  height: 60px;                  /* <-- increased from 50px to match level2 spacing */
  line-height: 60px;             /* <-- updated to match new height */
  text-align: center;
  background: #ececec;
  transition: background 0.2s;
}

.slot.level2 {
  height: 160px;                 /* <-- increased height to prevent overflow */
  line-height: 1.4em;            
  font-family: monospace; 
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  align-items:center;
}

/* Fix for consistent vertical spacing */
.slot.level2 * {
  line-height: 1.4em;
  vertical-align: baseline;
  display: inline-block;
  width: 100%;
  text-align: center;
}
  .activated { background:#88ffaa; }
  #progress { margin:8px; }

  /* start overlay */
  #startOverlay {
    position:absolute;
    top:0; left:0;
    width:100%; height:100%;
    background:rgba(0,0,0,0.4);
    color:white;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-size:20px;
  }

  /* Truth-table grid (Level2) */
  #truthGrid {
    border-collapse: collapse;
    font-size:14px;
    margin-top:4px;
  }
  #truthGrid th, #truthGrid td {
    padding:2px 6px;
    text-align:center;
  }
  #truthGrid thead tr { border-bottom:1px solid black; }
  #truthGrid th:nth-child(2), #truthGrid td:nth-child(2) {
    border-right:1px solid black;
  }
  .output-true { font-weight:bold; }
</style>
</head>
<body>

<div id="gameArea" style="position:relative; width:800px;">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <!-- Slot container used for both levels -->
  <div id="slotContainer" style="position:absolute; left:0; bottom:0; width:800px; display:none;">
    <div class="slot" data-name="">Slot1</div>
    <div class="slot" data-name="">Slot2</div>
    <div class="slot" data-name="">Slot3</div>
    <div class="slot" data-name="">Slot4</div>
    <div class="slot" data-name="">Slot5</div>
  </div>
</div>
  

<div id="progress"></div>

<div id="startOverlay">
 <h2> [Vibecoding in progress...not yet playable] <br/> Press <b>1</b> to play Level 1<br/>Press <b>2</b> to play Level 2 </h2>
</div>


<script>
// ======== Canvas + DOM Setup ========
const canvas = document.getElementById("gameCanvas");
const ctx    = canvas.getContext("2d");

const startOverlay  = document.getElementById("startOverlay");
const slotContainer = document.getElementById("slotContainer");
const progressDiv   = document.getElementById("progress");

// ======== Data ========
let level = 0;                   // 0 = not started, 1 or 2
let handledPieces = 0;
let totalPieces   = 30;          
let speedMultiplier = 1;
let baseFallSpeed = 1.5;

let currentPiece   = null;
let columnHeights  = [0,0,0,0,0];
const blockHeight  = 60;          // <-- increased from 50 to match new slot height
const maxBlocks    = 10;          // <-- reduced since blocks are taller now

// Level 1 symbols / mapping
const level1Symbols = ["∧","&","∨","¬","→","⊃","↔","≡"];
const symbolToName = {
  "∧":"AND","&":"AND",
  "∨":"OR",
  "¬":"NOT",
  "→":"IF…THEN","⊃":"IF…THEN",
  "↔":"IFF","≡":"IFF"
};

// Level 2 (binary only)
const binarySymbols = ["∧","∨","→","↔"];
const truthPatterns = {
  "AND": ["T","F","F","F"],
  "OR" : ["T","T","T","F"],
  "IF…THEN": ["T","F","T","T"],
  "IFF": ["T","F","F","T"]
};
const patternNames = ["AND","OR","IF…THEN","IFF"];

// ======== Start Screen Key ========
document.addEventListener("keydown", chooseLevel);

function chooseLevel(e){
  if(e.key === "1"){ level = 1; beginGame(); }
  if(e.key === "2"){ level = 2; beginGame(); }
}

// ======== Game Start ========
function beginGame(){
  startOverlay.style.display = "none";
  document.removeEventListener("keydown", chooseLevel);

  handledPieces = 0;
  speedMultiplier = 1;
  columnHeights = [0,0,0,0,0];

  // Clear all slots first - this is the key fix
  clearAllSlots();

  if (level === 1) {
    totalPieces = 30;
    canvas.height = 600;
    baseFallSpeed = 1.5;
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.remove("level2"));
    loadLevel1Slots();

  } else {
    totalPieces = 30;
    canvas.height = 450;
    baseFallSpeed = 5;
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.add("level2"));
    setupLevel2Slots();
  }

  spawnPiece();
  requestAnimationFrame(gameLoop);
}

// ======== NEW: Clear all slots function ========
function clearAllSlots() {
  for(let i = 0; i < 5; i++) {
    const slot = slotContainer.children[i];
    slot.innerHTML = "";
    slot.classList.remove("activated");
    slot.dataset.name = "";
  }
}

// ======== Level 1 slot labels ========
function loadLevel1Slots(){
  const labels = ["AND", "OR", "NOT", "IF…THEN", "IFF"];
  
  for(let i = 0; i < 5; i++) {
    slotContainer.children[i].innerHTML = labels[i];
    slotContainer.children[i].dataset.name = labels[i];
  }
}

// ======== Level 2 slots (AB + shuffled patterns) ========

function shuffle(array) {
  const a = [...array];
  for(let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
  
function setupLevel2Slots(){
  // Input column in slot 0
  slotContainer.children[0].innerHTML =
    "<span>A&nbsp;B</span><br><span>T&nbsp;&nbsp;T</span><br><span>T&nbsp;&nbsp;F</span><br><span>F&nbsp;&nbsp;T</span><br><span>F&nbsp;&nbsp;F</span>";

  // shuffle the 4 patterns
  const shuffled = shuffle(patternNames);

  // fill slots 1..4 - now properly clearing each slot first
  for(let col = 1; col < 5; col++){
    const patName = shuffled[col-1];
    const pattern = truthPatterns[patName];
    let html = "<span>&nbsp;</span><br>";   // top blank row for alignment
    
    for(const v of pattern){
      // Use spans with consistent styling instead of <b> tags
      const weight = v === "T" ? "font-weight:bold;" : "font-weight:normal;";
      html += `<span style="${weight}">${v}</span><br>`;
    }
    
    slotContainer.children[col].innerHTML = html;
    slotContainer.children[col].dataset.name = patName;
  }
}

// ======== Spawn ========
function spawnPiece(){
  if(level === 1){
    const s = level1Symbols[Math.floor(Math.random()*level1Symbols.length)];
    currentPiece = {symbol:s,x:400,y:0};
  } else {
    const s = binarySymbols[Math.floor(Math.random()*binarySymbols.length)];
    currentPiece = {symbol:s,x:320,y:0}; // approx column 2
  }
}
  

// ======== Key Input (move/drop) ========
document.addEventListener("keydown",(e)=>{
  if(level === 0 || !currentPiece) return;
  const colWidth = canvas.width/5;

  if(e.key==="ArrowLeft")  currentPiece.x -= colWidth;
  if(e.key==="ArrowRight") currentPiece.x += colWidth;
  if(e.key===" ")          dropPiece();
});

// ======== Drop Logic ========
function dropPiece(){
  const colWidth = canvas.width/5;
  const slotIndex = Math.floor(currentPiece.x / colWidth);

  // Level 1
  if(level === 1){
    const slotName = slotContainer.children[slotIndex].dataset.name;
    const expected = symbolToName[currentPiece.symbol];
    if(slotName === expected){
      slotContainer.children[slotIndex].classList.add("activated");
      checkComboLevel1();
    } else {
      columnHeights[slotIndex]++;
      slotContainer.children[slotIndex].classList.remove("activated");
    }
  }

  // Level 2
  if(level === 2){
    if(slotIndex === 0){
      // AB column -> wrong
      columnHeights[0]++;
    } else {
      const slotName = slotContainer.children[slotIndex].dataset.name;
      const expected = symbolToName[currentPiece.symbol];
      if(slotName === expected){
        slotContainer.children[slotIndex].classList.add("activated");
        checkComboLevel2();
      } else {
        columnHeights[slotIndex]++;
        slotContainer.children[slotIndex].classList.remove("activated");
      }
    }
  }

  handledPieces++;
  updateProgressAndCheckEnd();
  speedMultiplier *= 1.02;
  spawnPiece();
}

// ======== Combo Checkers ========
function checkComboLevel1(){
  const allAct = [...slotContainer.children]
    .every(el=>el.classList.contains("activated"));
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [...slotContainer.children].forEach(el=>el.classList.remove("activated"));
  }
}
function checkComboLevel2(){
  // must activate slots 1,2,3,4
  const allAct = [1,2,3,4].every(i =>
    slotContainer.children[i].classList.contains("activated")
  );
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [1,2,3,4].forEach(i => slotContainer.children[i].classList.remove("activated"));
  }
}

// ======== Progress + End ========
function updateProgressAndCheckEnd(){
  progressDiv.textContent = handledPieces + " / " + totalPieces;
  if(columnHeights.some(h=>h>=maxBlocks)){
    alert("Game Over");
    window.location.reload();
  }
  if(handledPieces >= totalPieces){
    alert("Level Complete!");
    window.location.reload();
  }
}

// ======== Game Loop ========
function gameLoop(){
  if(level === 0){ requestAnimationFrame(gameLoop); return; }
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw stones (error blocks)
  const slotHeight = level === 2 ? 160 : 60; // Get current slot height
  for(let i=0;i<5;i++){
    if(columnHeights[i]>0){
      ctx.fillStyle="#777";
      // Draw from bottom of canvas minus slot height, going up
      const startY = canvas.height - slotHeight - (columnHeights[i] * blockHeight);
      ctx.fillRect(i*(canvas.width/5),
                   startY,
                   (canvas.width/5),
                   columnHeights[i]*blockHeight);
    }
  }

  // draw current piece
  if(currentPiece){
    currentPiece.y += (2/(baseFallSpeed*speedMultiplier));
    ctx.font="32px sans-serif";
    ctx.textAlign="center";
    ctx.fillStyle="#000";
    ctx.fillText(currentPiece.symbol,
      (Math.floor(currentPiece.x/(canvas.width/5))*(canvas.width/5)) + (canvas.width/10),
      currentPiece.y);

    // Check if piece hits the bottom (accounting for slot height)
    const slotHeight = level === 2 ? 160 : 60;
    if(currentPiece.y >= canvas.height - slotHeight - blockHeight){
      dropPiece();
    }
  }
  requestAnimationFrame(gameLoop);
}
</script>

</body>
</html>
