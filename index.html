<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Logic Tetris MVP – Levels 1 & 2</title>
<style>
  body {
    background: linear-gradient(135deg, #2a5da7, #1a4d97);
    color: #ffffff;
    font-family: 'Arial', sans-serif;
    margin: 0;
    padding: 20px;
  }

  #pageTitle {
    font-size: 36px;
    letter-spacing: 2px;
    margin: 20px 0;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  }

  #gameCanvas {
    border: 3px solid #ffffff;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }

  #gameArea {
    position: relative;
    width: 800px;
    margin: 0 auto;
  }

  #slotContainer {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 800px;
    display: none;
    gap: 2px;
  }

  .slot {
    flex: 1;
    height: 60px;
    line-height: 60px;
    text-align: center;
    background: #ff8c42; /* Orange background */
    color: #000;
    transition: all 0.3s ease;
    border-radius: 8px 8px 0 0;
    border: 2px solid #e67e22;
    font-weight: bold;
    font-size: 14px;
    box-shadow: 0 -2px 8px rgba(0,0,0,0.2);
  }

  .slot.level2 {
    height: 180px;
    line-height: 1.4em;
    font-family: monospace;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    padding: 8px 4px;
    background: #ff8c42; /* Maintain orange for level 2 */
    border: 2px solid #e67e22;
  }

  /* Activated slot styling */
  .slot.activated {
    background: #ffd700 !important; /* Bright yellow when activated */
    border-color: #ffb300 !important;
    transform: translateY(-2px);
    box-shadow: 0 -4px 12px rgba(255, 215, 0, 0.4);
  }

  /* Level 2 specific text styling */
  .slot.level2 span {
    color: #000;
    line-height: 1.4em;
    display: block;
    width: 100%;
    text-align: center;
    margin: 1px 0;
  }

  #progress {
    margin: 15px;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    background: rgba(255,255,255,0.1);
    padding: 10px;
    border-radius: 20px;
    display: inline-block;
  }

  /* Start overlay improvements */
  #startOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 18px;
    border-radius: 8px;
  }

  #startOverlay h1 {
    font-size: 42px;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }

  #startOverlay p {
    margin: 15px 0;
    line-height: 1.5;
  }

  #startOverlay b {
    color: #ffd700;
  }

  /* Truth table styling */
  #truthGrid {
    border-collapse: collapse;
    font-size: 12px;
    margin-top: 4px;
  }

  #truthGrid th, #truthGrid td {
    padding: 2px 4px;
    text-align: center;
  }

  #truthGrid thead tr {
    border-bottom: 1px solid black;
  }

  #truthGrid th:nth-child(2), #truthGrid td:nth-child(2) {
    border-right: 1px solid black;
  }

  .output-true {
    font-weight: bold;
  }

  /* Hover effects for slots */
  .slot:hover {
    transform: translateY(-1px);
    box-shadow: 0 -3px 10px rgba(0,0,0,0.3);
  }

  /* Game pieces styling enhancement */
  .falling-piece {
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    font-weight: bold;
  }
</style>
</head>
<body>

<h1 id="pageTitle">TFL Symbol Tetris</h1>

<div id="gameArea">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <!-- Slot container used for both levels -->
  <div id="slotContainer">
    <div class="slot" data-name="">Slot1</div>
    <div class="slot" data-name="">Slot2</div>
    <div class="slot" data-name="">Slot3</div>
    <div class="slot" data-name="">Slot4</div>
    <div class="slot" data-name="">Slot5</div>
  </div>
</div>

<div id="progress"></div>

<div id="startOverlay">
  <div>
    <h1>TFL Symbol Tetris</h1>
    <p>Drop each logical symbol in the correct column.</p>
    <p>
      <b>← / →</b> = move &nbsp;&nbsp; • &nbsp;&nbsp; <b>Spacebar</b> = drop
    </p>
    <p>
      Activate all 5 columns at once to clear a stone row.<br>
      Game over if any stone column reaches the top.
    </p>
    <p>Press <b>1</b> to play Level 1 — Symbol → English Name<br/>
    Press <b>2</b> to play Level 2 — Symbol → Truth Table</p>
  </div>
</div>

<script>
// ======== Canvas + DOM Setup ========
const canvas = document.getElementById("gameCanvas");
const ctx    = canvas.getContext("2d");

const startOverlay  = document.getElementById("startOverlay");
const slotContainer = document.getElementById("slotContainer");
const progressDiv   = document.getElementById("progress");

// ======== Data ========
let level = 0;                   // 0 = not started, 1 or 2
let handledPieces = 0;
let totalPieces   = 30;          
let speedMultiplier = 1;
let baseFallSpeed = 1.5;

let currentPiece   = null;
let columnHeights  = [0,0,0,0,0];
const blockHeight  = 60;          // <-- increased from 50 to match new slot height
const maxBlocks    = 10;          // <-- reduced since blocks are taller now

// Level 1 symbols / mapping
const level1Symbols = ["∧","&","∨","¬","→","⊃","↔","≡"];
const symbolToName = {
  "∧":"AND","&":"AND",
  "∨":"OR",
  "¬":"NOT",
  "→":"IF…THEN","⊃":"IF…THEN",
  "↔":"IFF","≡":"IFF"
};

// Level 2 (binary only)
const binarySymbols = ["∧","∨","→","↔"];
const truthPatterns = {
  "AND": ["T","F","F","F"],
  "OR" : ["T","T","T","F"],
  "IF…THEN": ["T","F","T","T"],
  "IFF": ["T","F","F","T"]
};
const patternNames = ["AND","OR","IF…THEN","IFF"];

// ======== Start Screen Key ========
document.addEventListener("keydown", chooseLevel);

function chooseLevel(e){
  if(e.key === "1"){ level = 1; beginGame(); }
  if(e.key === "2"){ level = 2; beginGame(); }
}

// ======== Game Start ========
function beginGame(){
  startOverlay.style.display = "none";
  document.removeEventListener("keydown", chooseLevel);

  handledPieces = 0;
  speedMultiplier = 1;
  columnHeights = [0,0,0,0,0];

  // Clear all slots first - this is the key fix
  clearAllSlots();

  if (level === 1) {
    totalPieces = 30;
    canvas.height = 600;
    baseFallSpeed = 1.5;
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.remove("level2"));
    loadLevel1Slots();

  } else {
    totalPieces = 30;
    canvas.height = 450;
    baseFallSpeed = 5;
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.add("level2"));
    setupLevel2Slots();
  }

  spawnPiece();
  requestAnimationFrame(gameLoop);
}

// ======== NEW: Clear all slots function ========
function clearAllSlots() {
  for(let i = 0; i < 5; i++) {
    const slot = slotContainer.children[i];
    slot.innerHTML = "";
    slot.classList.remove("activated");
    slot.dataset.name = "";
  }
}

// ======== Level 1 slot labels ========
function loadLevel1Slots(){
  const labels = ["AND", "OR", "NOT", "IF…THEN", "IFF"];
  
  for(let i = 0; i < 5; i++) {
    slotContainer.children[i].innerHTML = labels[i];
    slotContainer.children[i].dataset.name = labels[i];
  }
}

// ======== Level 2 slots (AB + shuffled patterns) ========

function shuffle(array) {
  const a = [...array];
  for(let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
  
function setupLevel2Slots(){
  // Input column in slot 0
  slotContainer.children[0].innerHTML =
    "<span>A&nbsp;B</span><span>T&nbsp;&nbsp;T</span><span>T&nbsp;&nbsp;F</span><span>F&nbsp;&nbsp;T</span><span>F&nbsp;&nbsp;F</span>";

  // shuffle the 4 patterns
  const shuffled = shuffle(patternNames);

  // fill slots 1..4 - now properly clearing each slot first
  for(let col = 1; col < 5; col++){
    const patName = shuffled[col-1];
    const pattern = truthPatterns[patName];
    let html = "<span>&nbsp;</span>";   // top blank row for alignment
    
    for(const v of pattern){
      // Use spans with consistent styling instead of <b> tags
      const weight = v === "T" ? "font-weight:bold;" : "font-weight:normal;";
      html += `<span style="${weight}">${v}</span>`;
    }
    
    slotContainer.children[col].innerHTML = html;
    slotContainer.children[col].dataset.name = patName;
  }
}

// ======== Spawn ========
function spawnPiece(){
  if(level === 1){
    const s = level1Symbols[Math.floor(Math.random()*level1Symbols.length)];
    currentPiece = {symbol:s,x:400,y:0};
  } else {
    const s = binarySymbols[Math.floor(Math.random()*binarySymbols.length)];
    currentPiece = {symbol:s,x:320,y:0}; // approx column 2
  }
}
  

// ======== Key Input (move/drop) ========
document.addEventListener("keydown",(e)=>{
  if(level === 0 || !currentPiece) return;
  const colWidth = canvas.width/5;

  if(e.key==="ArrowLeft")  currentPiece.x -= colWidth;
  if(e.key==="ArrowRight") currentPiece.x += colWidth;
  if(e.key===" ")          dropPiece();
});

// ======== Drop Logic ========
function dropPiece(){
  const colWidth = canvas.width/5;
  const slotIndex = Math.floor(currentPiece.x / colWidth);

  // Level 1
  if(level === 1){
    const slotName = slotContainer.children[slotIndex].dataset.name;
    const expected = symbolToName[currentPiece.symbol];
    if(slotName === expected){
      slotContainer.children[slotIndex].classList.add("activated");
      checkComboLevel1();
    } else {
      columnHeights[slotIndex]++;
      slotContainer.children[slotIndex].classList.remove("activated");
    }
  }

  // Level 2
  if(level === 2){
    if(slotIndex === 0){
      // AB column -> wrong
      columnHeights[0]++;
    } else {
      const slotName = slotContainer.children[slotIndex].dataset.name;
      const expected = symbolToName[currentPiece.symbol];
      if(slotName === expected){
        slotContainer.children[slotIndex].classList.add("activated");
        checkComboLevel2();
      } else {
        columnHeights[slotIndex]++;
        slotContainer.children[slotIndex].classList.remove("activated");
      }
    }
  }

  handledPieces++;
  updateProgressAndCheckEnd();
  speedMultiplier *= 1.02;
  spawnPiece();
}

// ======== Combo Checkers ========
function checkComboLevel1(){
  const allAct = [...slotContainer.children]
    .every(el=>el.classList.contains("activated"));
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [...slotContainer.children].forEach(el=>el.classList.remove("activated"));
  }
}
function checkComboLevel2(){
  // must activate slots 1,2,3,4
  const allAct = [1,2,3,4].every(i =>
    slotContainer.children[i].classList.contains("activated")
  );
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [1,2,3,4].forEach(i => slotContainer.children[i].classList.remove("activated"));
  }
}

// ======== Progress + End ========
function updateProgressAndCheckEnd(){
  progressDiv.textContent = `Progress: ${handledPieces} / ${totalPieces}`;
  if(columnHeights.some(h=>h>=maxBlocks)){
    alert("Game Over! Try again?");
    window.location.reload();
  }
  if(handledPieces >= totalPieces){
    alert("Level Complete! Well done!");
    window.location.reload();
  }
}

// ======== Game Loop ========
function gameLoop(){
  if(level === 0){ requestAnimationFrame(gameLoop); return; }
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw stones (error blocks)
  const slotHeight = level === 2 ? 180 : 60; // Get current slot height
  for(let i=0;i<5;i++){
    if(columnHeights[i]>0){
      ctx.fillStyle="#cc4444";
      ctx.strokeStyle="#aa3333";
      ctx.lineWidth = 2;
      // Draw from bottom of canvas minus slot height, going up
      const startY = canvas.height - slotHeight - (columnHeights[i] * blockHeight);
      ctx.fillRect(i*(canvas.width/5) + 2,
                   startY,
                   (canvas.width/5) - 4,
                   columnHeights[i]*blockHeight);
      ctx.strokeRect(i*(canvas.width/5) + 2,
                     startY,
                     (canvas.width/5) - 4,
                     columnHeights[i]*blockHeight);
    }
  }

  // draw current piece with better styling
  if(currentPiece){
    currentPiece.y += (2/(baseFallSpeed*speedMultiplier));
    ctx.font="bold 36px Arial";
    ctx.textAlign="center";
    ctx.fillStyle="#ffffff";
    ctx.strokeStyle="#000000";
    ctx.lineWidth = 2;
    const pieceX = (Math.floor(currentPiece.x/(canvas.width/5))*(canvas.width/5)) + (canvas.width/10);
    
    // Draw text with outline
    ctx.strokeText(currentPiece.symbol, pieceX, currentPiece.y);
    ctx.fillText(currentPiece.symbol, pieceX, currentPiece.y);

    // Check if piece hits the bottom (accounting for slot height)
    if(currentPiece.y >= canvas.height - slotHeight - blockHeight){
      dropPiece();
    }
  }
  requestAnimationFrame(gameLoop);
}
</script>

</body>
</html>
