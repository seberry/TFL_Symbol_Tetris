<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Logic Tetris MVP – Levels 1 & 2</title>
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #a0cfff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #gameCanvas {
    border: 1px solid #333;
    background: transparent;
  }
  #slotContainer {
  position: absolute;
  left: 0;
  bottom: 0;
  width: 800px;
  display: none;   /* <-- JS will set this to "flex" at start */
}
  .slot {
  flex: 1;
  height: 50px;
  line-height: 50px;
  text-align: center;
  background: #ececec;
  transition: background 0.2s;
}

.slot.level2 {
  height: 140px;
  line-height: 1.1em;            /* <-- fixed line height for all lines */
  font-family: monospace; 
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  align-items:center;
}
  .activated { background:#88ffaa; }
  #progress { margin:8px; }

  /* start overlay */
  #startOverlay {
    position:absolute;
    top:0; left:0;
    width:100%; height:100%;
    background:rgba(0,0,0,0.4);
    color:white;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-size:20px;
  }

  /* Truth-table grid (Level2) */
  #truthGrid {
    border-collapse: collapse;
    font-size:14px;
    margin-top:4px;
  }
  #truthGrid th, #truthGrid td {
    padding:2px 6px;
    text-align:center;
  }
  #truthGrid thead tr { border-bottom:1px solid black; }
  #truthGrid th:nth-child(2), #truthGrid td:nth-child(2) {
    border-right:1px solid black;
  }
  .output-true { font-weight:bold; }
</style>
</head>
<body>

<div id="gameArea" style="position:relative; width:800px;">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <!-- Slot container used for both levels -->
  <div id="slotContainer" style="position:absolute; left:0; bottom:0; width:800px; display:none;">
    <div class="slot" data-name="">Slot1</div>
    <div class="slot" data-name="">Slot2</div>
    <div class="slot" data-name="">Slot3</div>
    <div class="slot" data-name="">Slot4</div>
    <div class="slot" data-name="">Slot5</div>
  </div>
</div>
  

<div id="progress"></div>

<div id="startOverlay">
 <h2> [Vibecoding in progress...not yet playable] <br/> Press <b>1</b> to play Level 1<br/>Press <b>2</b> to play Level 2 </h2>
</div>


<script>
// ======== Canvas + DOM Setup ========
const canvas = document.getElementById("gameCanvas");
const ctx    = canvas.getContext("2d");

const startOverlay  = document.getElementById("startOverlay");
const slotContainer = document.getElementById("slotContainer");
const progressDiv   = document.getElementById("progress");

// ======== Data ========
let level = 0;                   // 0 = not started, 1 or 2
let handledPieces = 0;
let totalPieces   = 30;          
let speedMultiplier = 1;
let baseFallSpeed = 1.5;

let currentPiece   = null;
let columnHeights  = [0,0,0,0,0];
const blockHeight  = 50;
const maxBlocks    = 12;

// Level 1 symbols / mapping
const level1Symbols = ["∧","&","∨","¬","→","⊃","↔","≡"];
const symbolToName = {
  "∧":"AND","&":"AND",
  "∨":"OR",
  "¬":"NOT",
  "→":"IF…THEN","⊃":"IF…THEN",
  "↔":"IFF","≡":"IFF"
};

// Level 2 (binary only)
const binarySymbols = ["∧","∨","→","↔"];
const truthPatterns = {
  "AND": ["T","F","F","F"],
  "OR" : ["T","T","T","F"],
  "IF…THEN": ["T","F","T","T"],
  "IFF": ["T","F","F","T"]
};
const patternNames = ["AND","OR","IMP","IFF"];

// ======== Start Screen Key ========
document.addEventListener("keydown", chooseLevel);

function chooseLevel(e){
  if(e.key === "1"){ level = 1; beginGame(); }
  if(e.key === "2"){ level = 2; beginGame(); }
}

// ======== Game Start ========
function beginGame(){
  startOverlay.style.display = "none";
  document.removeEventListener("keydown", chooseLevel);

  handledPieces = 0;
  speedMultiplier = 1;
  columnHeights = [0,0,0,0,0];

  if (level === 1) {
    totalPieces = 30;
    canvas.height = 600;
    baseFallSpeed = 1.5;     // <-- fall speed for level 1
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.remove("level2"));
    loadLevel1Slots();

  } else {
    totalPieces = 30;
    canvas.height = 450;     // <-- shorter drop area
    baseFallSpeed = 3;     // <-- slower fall speed for level 2 (we divide by fallspeed when calculating delta x value below, so higher numbers mean slower) 
    slotContainer.style.display = "flex";
    [...slotContainer.children].forEach(el => el.classList.add("level2"));
    setupLevel2Slots();
  }


  spawnPiece();
  requestAnimationFrame(gameLoop);
}

// ======== Level 1 slot labels ========
function loadLevel1Slots(){
  slotContainer.children[0].innerHTML = "AND";
  slotContainer.children[1].innerHTML = "OR";
  slotContainer.children[2].innerHTML = "NOT";
  slotContainer.children[3].innerHTML = "IF…THEN";
  slotContainer.children[4].innerHTML = "IFF";
  // clear activation states
  for(let i=0;i<5;i++){
    slotContainer.children[i].classList.remove("activated");
    slotContainer.children[i].dataset.name = slotContainer.children[i].textContent;
  }
}

// ======== Level 2 slots (AB + shuffled patterns) ========
function setupLevel2Slots(){
  // Input column in slot 0
  slotContainer.children[0].innerHTML = "";   // clear any old label
slotContainer.children[0].innerHTML =
  "A&nbsp;B<br>T&nbsp;&nbsp;T<br>T&nbsp;&nbsp;F<br>F&nbsp;&nbsp;T<br>F&nbsp;&nbsp;F";

  // shuffle the 4 patterns
  const shuffled = patternNames.sort(() => Math.random() - 0.5);

  // fill slots 1..4
  for(let col=1; col<5; col++){
    const patName = shuffled[col-1];   // use first 4 from shuffle
    const pattern = truthPatterns[patName];
    let html = "&nbsp;&nbsp;<br>";   // add one blank row so patterns align with A/B header
// top blank row for alignment
    for(const v of pattern){
      html += (v==="T" ? "<b>T</b>" : "F") + "<br>";
    }
    slotContainer.children[col].innerHTML = html;
    slotContainer.children[col].dataset.name = patName;
    slotContainer.children[col].classList.remove("activated");
  }
}

// ======== Spawn ========
function spawnPiece(){
  if(level === 1){
    const s = level1Symbols[Math.floor(Math.random()*level1Symbols.length)];
    currentPiece = {symbol:s,x:400,y:0};
  } else {
    const s = binarySymbols[Math.floor(Math.random()*binarySymbols.length)];
    currentPiece = {symbol:s,x:320,y:0}; // approx column 2
  }
}
  

// ======== Key Input (move/drop) ========
document.addEventListener("keydown",(e)=>{
  if(level === 0 || !currentPiece) return;
  const colWidth = canvas.width/5;

  if(e.key==="ArrowLeft")  currentPiece.x -= colWidth;
  if(e.key==="ArrowRight") currentPiece.x += colWidth;
  if(e.key===" ")          dropPiece();
});

// ======== Drop Logic ========
function dropPiece(){
  const colWidth = canvas.width/5;
  const slotIndex = Math.floor(currentPiece.x / colWidth);

  // Level 1
  if(level === 1){
    const slotName = slotContainer.children[slotIndex].dataset.name;
    const expected = symbolToName[currentPiece.symbol];
    if(slotName === expected){
      slotContainer.children[slotIndex].classList.add("activated");
      checkComboLevel1();
    } else {
      columnHeights[slotIndex]++;
      slotContainer.children[slotIndex].classList.remove("activated");
    }
  }

  // Level 2
  if(level === 2){
    if(slotIndex === 0){
      // AB column -> wrong
      columnHeights[0]++;
    } else {
      const slotName = slotContainer.children[slotIndex].dataset.name;
      const expected = symbolToName[currentPiece.symbol];
      if(slotName === expected){
        slotContainer.children[slotIndex].classList.add("activated");
        checkComboLevel2();
      } else {
        columnHeights[slotIndex]++;
        slotContainer.children[slotIndex].classList.remove("activated");
      }
    }
  }

  handledPieces++;
  updateProgressAndCheckEnd();
  speedMultiplier *= 1.02;
  spawnPiece();
}

// ======== Combo Checkers ========
function checkComboLevel1(){
  const allAct = [...slotContainer.children]
    .every(el=>el.classList.contains("activated"));
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [...slotContainer.children].forEach(el=>el.classList.remove("activated"));
  }
}
function checkComboLevel2(){
  // must activate slots 1,2,3,4
  const allAct = [1,2,3,4].every(i =>
    slotContainer.children[i].classList.contains("activated")
  );
  if(allAct){
    for(let i=0;i<5;i++) columnHeights[i]=Math.max(0,columnHeights[i]-1);
    [1,2,3,4].forEach(i => slotContainer.children[i].classList.remove("activated"));
  }
}

// ======== Progress + End ========
function updateProgressAndCheckEnd(){
  progressDiv.textContent = handledPieces + " / " + totalPieces;
  if(columnHeights.some(h=>h>=maxBlocks)){
    alert("Game Over");
    window.location.reload();
  }
  if(handledPieces >= totalPieces){
    alert("Level Complete!");
    window.location.reload();
  }
}

// ======== Game Loop ========
function gameLoop(){
  if(level === 0){ requestAnimationFrame(gameLoop); return; }
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw stones
  for(let i=0;i<5;i++){
    if(columnHeights[i]>0){
      ctx.fillStyle="#777";
      ctx.fillRect(i*(canvas.width/5),
                   canvas.height - columnHeights[i]*blockHeight,
                   (canvas.width/5),
                   columnHeights[i]*blockHeight);
    }
  }

  // draw current piece
  if(currentPiece){
    currentPiece.y += (2/(baseFallSpeed*speedMultiplier));
    ctx.font="32px sans-serif";
    ctx.textAlign="center";
    ctx.fillStyle="#000";
    ctx.fillText(currentPiece.symbol,
      (Math.floor(currentPiece.x/(canvas.width/5))*(canvas.width/5)) + (canvas.width/10),
      currentPiece.y);

    if(currentPiece.y >= canvas.height - blockHeight){
      dropPiece();
    }
  }
  requestAnimationFrame(gameLoop);
}
</script>




</body>
</html>
1
