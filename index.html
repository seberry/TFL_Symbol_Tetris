<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const slots = Array.from(document.querySelectorAll(".slot"));
const symbols = ["∧", "∨", "¬", "→", "↔"];
const symbolToName = {
  "∧": "AND",
  "∨": "OR",
  "¬": "NOT",
  "→": "IF…THEN",
  "↔": "IFF"
};

const totalPieces = 30;
let handledPieces = 0;
let columnHeights = [0,0,0,0,0];
const blockHeight = 50;
const maxBlocks = 12;
let currentPiece = null;

let baseFallSpeed = 1.5;
let speedMultiplier = 1;

// ---- Placeholder audio (simple oscillator beeps) -----
function playBeep(freq, duration=100) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = "square";
  osc.frequency.value = freq;
  osc.start();
  gain.gain.setValueAtTime(0.3, ctx.currentTime);
  osc.stop(ctx.currentTime + duration/1000);
}
// -----------------------------------------------------

spawnPiece();
document.addEventListener("keydown", handleKey);

function spawnPiece() {
  const symbol = symbols[Math.floor(Math.random() * symbols.length)];
  currentPiece = {
    symbol,
    x: 400,
    y: 0
  };
}

function handleKey(e) {
  if (!currentPiece) return;
  const slotWidth = canvas.width / 5;

  if (e.key === "ArrowLeft") {
    currentPiece.x = Math.max(0, currentPiece.x - slotWidth);
  } else if (e.key === "ArrowRight") {
    currentPiece.x = Math.min(canvas.width - slotWidth, currentPiece.x + slotWidth);
  } else if (e.key === " ") {
    dropPiece();
  }
}

function dropPiece() {
  const slotIndex = Math.floor(currentPiece.x / (canvas.width / 5));
  const slotName = slots[slotIndex].dataset.name;
  const expectedName = symbolToName[currentPiece.symbol];

  if (slotName === expectedName) {
    // ------ Correct drop ------
    slots[slotIndex].classList.add("activated");
    playBeep(660);                     // success sound

    // Check combo (are all 5 activated?)
    if (slots.every(s => s.classList.contains("activated"))) {
      // Clear one stone row and reset activations
      for (let i = 0; i < columnHeights.length; i++) {
        columnHeights[i] = Math.max(0, columnHeights[i] - 1);
      }
      slots.forEach(s => s.classList.remove("activated"));
      playBeep(240);  // lower-tone "crumble" beep
    }

  } else {
    // ------ Incorrect drop ------
    columnHeights[slotIndex]++;
    slots[slotIndex].classList.remove("activated");
    playBeep(300);   // error beep
  }

  handledPieces++;
  updateProgress();

  // check lose condition
  if (columnHeights.some(h => h >= maxBlocks)) {
    alert("Game over!");
    window.location.reload();
    return;
  }

  // Level done?
  if (handledPieces >= totalPieces) {
    alert("Level complete!");
    window.location.reload();
    return;
  }

  // slow ramp
  speedMultiplier *= 1.02;
  spawnPiece();
}

function updateProgress() {
  document.getElementById("progress").textContent =
    handledPieces + " / " + totalPieces;
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw stone blocks
  for (let i = 0; i < 5; i++) {
    const h = columnHeights[i];
    if (h > 0) {
      ctx.fillStyle = "#777";
      ctx.fillRect(
        i * (canvas.width/5),
        canvas.height - h * blockHeight,
        canvas.width/5,
        h * blockHeight
      );
    }
  }

  // draw current piece
  if (currentPiece) {
    const fallPx = (2 / (baseFallSpeed * speedMultiplier));
    currentPiece.y += fallPx;
    ctx.font = "32px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#000";

    const slotWidth = canvas.width / 5;
    const xCenter = (Math.floor(currentPiece.x / slotWidth) * slotWidth) + slotWidth/2;
    ctx.fillText(currentPiece.symbol, xCenter, currentPiece.y);

    if (currentPiece.y >= canvas.height - blockHeight) {
      dropPiece();
    }
  }

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
